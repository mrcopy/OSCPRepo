<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>PEDA</title>
</head><body>b main&#09;&#09;&#09;&#09;add a breakpoint on the 'main' function<br/>
r&#09;&#09;&#09;&#09;&#09;run / rerun<br/>
checksec&#09;&#09;&#09;&#09;view binaries compiled security flags (canary/fortify/NX/pie/relro)<br/>
n &#09;&#09;&#09;&#09;&#09;next<br/>
ni&#09;&#09;&#09;&#09;&#09;next one exactly<br/>
s &#09;&#09;&#09;&#09;&#09;step until source line<br/>
si&#09;&#09;&#09;&#09;&#09;one step into (one code execution exactly)<br/>
x/s &lt;address&gt;&#09;&#09;&#09;Hex to String (ascii)?<br/>
p &lt;function&gt;&#09;&#09;&#09;print &lt;function<br/>
searchmem &lt;function&gt;&#09;searchmemory for a string/function<br/>
disas &lt;function&gt;&#09;&#09;disassemble function<br/>
c&#09;&#09;&#09;&#09;&#09;continue execution (step over?)<br/>
<br/>
can add PEDA to ~/.gdbinit<br/>
source ~/peda/peda.py<br/>
<br/>
<br/>
gdb (or peda?) can also create patterns<br/>
gdb&gt; pattern create 50<br/>
'AAA%AABAA$AAnAACAA-AA(AADAA;AA)AAAEAAaAA0AAFAAbA'<br/>
<br/>
and grab the offset<br/>
gdb&gt; pattern offset AA;A<br/>
AA;A found at offset: 28<br/>
<br/>
Turns out, when the binary is compiled with debug info (which gives access to the source along side the assembly), n ands execute to the next line of source. If you want to move one assembly instruction, use ni or si.<br/>
<br/>
Add commands to support debugging and exploit development (for a full list of commands use peda help):<br/>
<br/>
&nbsp; &nbsp; aslr -- Show/set ASLR setting of GDB<br/>
&nbsp; &nbsp; checksec -- Check for various security options of binary<br/>
&nbsp; &nbsp; dumpargs -- Display arguments passed to a function when stopped at a call instruction<br/>
&nbsp; &nbsp; dumprop -- Dump all ROP gadgets in specific memory range<br/>
&nbsp; &nbsp; elfheader -- Get headers information from debugged ELF file<br/>
&nbsp; &nbsp; elfsymbol -- Get non-debugging symbol information from an ELF file<br/>
&nbsp; &nbsp; lookup -- Search for all addresses/references to addresses which belong to a memory range<br/>
&nbsp; &nbsp; patch -- Patch memory start at an address with string/hexstring/int<br/>
&nbsp; &nbsp; pattern -- Generate, search, or write a cyclic pattern to memory<br/>
&nbsp; &nbsp; procinfo -- Display various info from /proc/pid/<br/>
&nbsp; &nbsp; pshow -- Show various PEDA options and other settings<br/>
&nbsp; &nbsp; pset -- Set various PEDA options and other settings<br/>
&nbsp; &nbsp; readelf -- Get headers information from an ELF file<br/>
&nbsp; &nbsp; ropgadget -- Get common ROP gadgets of binary or library<br/>
&nbsp; &nbsp; ropsearch -- Search for ROP gadgets in memory<br/>
&nbsp; &nbsp; searchmem|find -- Search for a pattern in memory; support regex search<br/>
&nbsp; &nbsp; shellcode -- Generate or download common shellcodes.<br/>
&nbsp; &nbsp; skeleton -- Generate python exploit code template<br/>
&nbsp; &nbsp; vmmap -- Get virtual mapping address ranges of section(s) in debugged process<br/>
&nbsp; &nbsp; xormem -- XOR a memory region with a key<br/>
</body></html>