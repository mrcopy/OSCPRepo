<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Gadgets</title>
</head><body>Gadgets<br/>
Now I’ll need some gadgets. In gdb with peda loaded, I ran dumprop, which writes a bunch of gadgets to a file, tiny-rop.txt. To call read, I’ll need to pass the socket descriptor in rsi, and the address to write to in rdi. So I need gadgets to pop into those registers. I’ll find these two:<br/>
<br/>
0x4011dd: pop rdi; ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;-- useful to pass parameters to read<br/>
0x4011db: pop rsi; pop r15; ret &nbsp;&lt;-- useful to pass parameters to read, ignoring r15<br/>
<br/>
So, this all adds up to the following payload:<br/>
<br/>
junk = &nbsp;"A" * 568 &nbsp; &nbsp; &nbsp;# junk<br/>
payload = ""<br/>
payload += p64(0x4011dd) &nbsp;# pop rdi; ret<br/>
payload += p64(4) &nbsp; &nbsp; &nbsp; &nbsp; # socket descriptor<br/>
payload += p64(0x4011db) &nbsp;# pop rsi; pop r15; ret<br/>
payload += p64(BSS) &nbsp; &nbsp; &nbsp; # BSS, to go to rsi<br/>
payload += p64(BSS) &nbsp; &nbsp; &nbsp; # junk for r15<br/>
payload += p64(read) &nbsp; &nbsp; &nbsp;# read<br/>
payload += p64(BSS) &nbsp; &nbsp; &nbsp; # return to shellcode<br/>
<br/>
I’ll walk through that in detail:<br/>
<ul><li>junk will be the right length so that when the program goes to return, the top of the stack will be the start of payload. Therefore, execution will return to the pop rdi; ret gadget, and 4 will sit on top of the stack.</li>
<li>pop rdi will take the 4 off the top of the stack and store it in rdi. This leaves the second gadget on top of the stack.</li>
<li>ret will move execution to the second gadget, leaving the address of bss on top of the stack.</li>
<li>The second gadget will pop twice, into rsi and r15. I don’t care about r15, but I needed the bss address in rsi. Now, the address of read sits on top of the stack.</li>
<li>ret will push execution to the read call, leaving the bss address on top of the stack. Because I now have the socket descriptor in rdi, and the bss address in rsi, it will read from the socket into bss.</li>
<li>If I had called read as a function, that would have pushed a new return address onto the stack. But since I just moved RIP there, when read returns, it will pop the next word off the stack for a return address, which is the bss address, where I just wrote my shellcode.</li>
</ul>
&nbsp;</body></html>